// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FBRESULT_OSRM_ENGINE_API_FBRESULT_H_
#define FLATBUFFERS_GENERATED_FBRESULT_OSRM_ENGINE_API_FBRESULT_H_

#include "flatbuffers/flatbuffers.h"

namespace osrm {
namespace engine {
namespace api {
namespace fbresult {

struct Position;
struct PositionT;

struct Waypoint;
struct WaypointT;

struct Metadata;
struct MetadataT;

struct Annotation;
struct AnnotationT;

struct StepManeuver;
struct StepManeuverT;

struct Lane;
struct LaneT;

struct Intersection;
struct IntersectionT;

struct Polyline;
struct PolylineT;

struct Step;
struct StepT;

struct Leg;
struct LegT;

struct RouteObject;
struct RouteObjectT;

struct Route;
struct RouteT;

struct Match;
struct MatchT;

struct Nearest;
struct NearestT;

struct VectorUint;
struct VectorUintT;

struct Table;
struct TableT;

struct Trip;
struct TripT;

struct FBResult;
struct FBResultT;

enum ManeuverType {
  ManeuverType_Turn = 0,
  ManeuverType_NewName = 1,
  ManeuverType_Depart = 2,
  ManeuverType_Arrive = 3,
  ManeuverType_Merge = 4,
  ManeuverType_OnRamp = 5,
  ManeuverType_OffRamp = 6,
  ManeuverType_Fork = 7,
  ManeuverType_EndOfRoad = 8,
  ManeuverType_Continue = 9,
  ManeuverType_Roundabout = 10,
  ManeuverType_Rotary = 11,
  ManeuverType_RoundaboutTurn = 12,
  ManeuverType_Notification = 13,
  ManeuverType_ExitRoundabout = 14,
  ManeuverType_ExitRotary = 15,
  ManeuverType_MIN = ManeuverType_Turn,
  ManeuverType_MAX = ManeuverType_ExitRotary
};

inline const ManeuverType (&EnumValuesManeuverType())[16] {
  static const ManeuverType values[] = {
    ManeuverType_Turn,
    ManeuverType_NewName,
    ManeuverType_Depart,
    ManeuverType_Arrive,
    ManeuverType_Merge,
    ManeuverType_OnRamp,
    ManeuverType_OffRamp,
    ManeuverType_Fork,
    ManeuverType_EndOfRoad,
    ManeuverType_Continue,
    ManeuverType_Roundabout,
    ManeuverType_Rotary,
    ManeuverType_RoundaboutTurn,
    ManeuverType_Notification,
    ManeuverType_ExitRoundabout,
    ManeuverType_ExitRotary
  };
  return values;
}

inline const char * const *EnumNamesManeuverType() {
  static const char * const names[17] = {
    "Turn",
    "NewName",
    "Depart",
    "Arrive",
    "Merge",
    "OnRamp",
    "OffRamp",
    "Fork",
    "EndOfRoad",
    "Continue",
    "Roundabout",
    "Rotary",
    "RoundaboutTurn",
    "Notification",
    "ExitRoundabout",
    "ExitRotary",
    nullptr
  };
  return names;
}

inline const char *EnumNameManeuverType(ManeuverType e) {
  if (e < ManeuverType_Turn || e > ManeuverType_ExitRotary) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesManeuverType()[index];
}

enum Turn {
  Turn_None = 0,
  Turn_UTurn = 1,
  Turn_SharpRight = 2,
  Turn_Right = 3,
  Turn_SlightRight = 4,
  Turn_Straight = 5,
  Turn_SlightLeft = 6,
  Turn_Left = 7,
  Turn_SharpLeft = 8,
  Turn_MIN = Turn_None,
  Turn_MAX = Turn_SharpLeft
};

inline const Turn (&EnumValuesTurn())[9] {
  static const Turn values[] = {
    Turn_None,
    Turn_UTurn,
    Turn_SharpRight,
    Turn_Right,
    Turn_SlightRight,
    Turn_Straight,
    Turn_SlightLeft,
    Turn_Left,
    Turn_SharpLeft
  };
  return values;
}

inline const char * const *EnumNamesTurn() {
  static const char * const names[10] = {
    "None",
    "UTurn",
    "SharpRight",
    "Right",
    "SlightRight",
    "Straight",
    "SlightLeft",
    "Left",
    "SharpLeft",
    nullptr
  };
  return names;
}

inline const char *EnumNameTurn(Turn e) {
  if (e < Turn_None || e > Turn_SharpLeft) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTurn()[index];
}

enum Geometry {
  Geometry_NONE = 0,
  Geometry_polyline = 1,
  Geometry_polyline6 = 2,
  Geometry_coordinates = 3,
  Geometry_MIN = Geometry_NONE,
  Geometry_MAX = Geometry_coordinates
};

inline const Geometry (&EnumValuesGeometry())[4] {
  static const Geometry values[] = {
    Geometry_NONE,
    Geometry_polyline,
    Geometry_polyline6,
    Geometry_coordinates
  };
  return values;
}

inline const char * const *EnumNamesGeometry() {
  static const char * const names[5] = {
    "NONE",
    "polyline",
    "polyline6",
    "coordinates",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometry(Geometry e) {
  if (e < Geometry_NONE || e > Geometry_coordinates) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometry()[index];
}

struct GeometryUnion {
  Geometry type;
  void *value;

  GeometryUnion() : type(Geometry_NONE), value(nullptr) {}
  GeometryUnion(GeometryUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Geometry_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  GeometryUnion(const GeometryUnion &) FLATBUFFERS_NOEXCEPT;
  GeometryUnion &operator=(const GeometryUnion &u) FLATBUFFERS_NOEXCEPT
    { GeometryUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  GeometryUnion &operator=(GeometryUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~GeometryUnion() { Reset(); }

  void Reset();

  static void *UnPack(const void *obj, Geometry type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  std::string *Aspolyline() {
    return type == Geometry_polyline ?
      reinterpret_cast<std::string *>(value) : nullptr;
  }
  const std::string *Aspolyline() const {
    return type == Geometry_polyline ?
      reinterpret_cast<const std::string *>(value) : nullptr;
  }
  std::string *Aspolyline6() {
    return type == Geometry_polyline6 ?
      reinterpret_cast<std::string *>(value) : nullptr;
  }
  const std::string *Aspolyline6() const {
    return type == Geometry_polyline6 ?
      reinterpret_cast<const std::string *>(value) : nullptr;
  }
  osrm::engine::api::fbresult::PolylineT *Ascoordinates() {
    return type == Geometry_coordinates ?
      reinterpret_cast<osrm::engine::api::fbresult::PolylineT *>(value) : nullptr;
  }
  const osrm::engine::api::fbresult::PolylineT *Ascoordinates() const {
    return type == Geometry_coordinates ?
      reinterpret_cast<const osrm::engine::api::fbresult::PolylineT *>(value) : nullptr;
  }
};

bool VerifyGeometry(flatbuffers::Verifier &verifier, const void *obj, Geometry type);
bool VerifyGeometryVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ServiceResponse {
  ServiceResponse_NONE = 0,
  ServiceResponse_match = 1,
  ServiceResponse_nearest = 2,
  ServiceResponse_route = 3,
  ServiceResponse_table = 4,
  ServiceResponse_trip = 5,
  ServiceResponse_MIN = ServiceResponse_NONE,
  ServiceResponse_MAX = ServiceResponse_trip
};

inline const ServiceResponse (&EnumValuesServiceResponse())[6] {
  static const ServiceResponse values[] = {
    ServiceResponse_NONE,
    ServiceResponse_match,
    ServiceResponse_nearest,
    ServiceResponse_route,
    ServiceResponse_table,
    ServiceResponse_trip
  };
  return values;
}

inline const char * const *EnumNamesServiceResponse() {
  static const char * const names[7] = {
    "NONE",
    "match",
    "nearest",
    "route",
    "table",
    "trip",
    nullptr
  };
  return names;
}

inline const char *EnumNameServiceResponse(ServiceResponse e) {
  if (e < ServiceResponse_NONE || e > ServiceResponse_trip) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServiceResponse()[index];
}

template<typename T> struct ServiceResponseTraits {
  static const ServiceResponse enum_value = ServiceResponse_NONE;
};

template<> struct ServiceResponseTraits<osrm::engine::api::fbresult::Match> {
  static const ServiceResponse enum_value = ServiceResponse_match;
};

template<> struct ServiceResponseTraits<osrm::engine::api::fbresult::Nearest> {
  static const ServiceResponse enum_value = ServiceResponse_nearest;
};

template<> struct ServiceResponseTraits<osrm::engine::api::fbresult::Route> {
  static const ServiceResponse enum_value = ServiceResponse_route;
};

template<> struct ServiceResponseTraits<osrm::engine::api::fbresult::Table> {
  static const ServiceResponse enum_value = ServiceResponse_table;
};

template<> struct ServiceResponseTraits<osrm::engine::api::fbresult::Trip> {
  static const ServiceResponse enum_value = ServiceResponse_trip;
};

struct ServiceResponseUnion {
  ServiceResponse type;
  void *value;

  ServiceResponseUnion() : type(ServiceResponse_NONE), value(nullptr) {}
  ServiceResponseUnion(ServiceResponseUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ServiceResponse_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ServiceResponseUnion(const ServiceResponseUnion &) FLATBUFFERS_NOEXCEPT;
  ServiceResponseUnion &operator=(const ServiceResponseUnion &u) FLATBUFFERS_NOEXCEPT
    { ServiceResponseUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ServiceResponseUnion &operator=(ServiceResponseUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ServiceResponseUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ServiceResponseTraits<typename RT::TableType>::enum_value;
    if (type != ServiceResponse_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ServiceResponse type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  osrm::engine::api::fbresult::MatchT *Asmatch() {
    return type == ServiceResponse_match ?
      reinterpret_cast<osrm::engine::api::fbresult::MatchT *>(value) : nullptr;
  }
  const osrm::engine::api::fbresult::MatchT *Asmatch() const {
    return type == ServiceResponse_match ?
      reinterpret_cast<const osrm::engine::api::fbresult::MatchT *>(value) : nullptr;
  }
  osrm::engine::api::fbresult::NearestT *Asnearest() {
    return type == ServiceResponse_nearest ?
      reinterpret_cast<osrm::engine::api::fbresult::NearestT *>(value) : nullptr;
  }
  const osrm::engine::api::fbresult::NearestT *Asnearest() const {
    return type == ServiceResponse_nearest ?
      reinterpret_cast<const osrm::engine::api::fbresult::NearestT *>(value) : nullptr;
  }
  osrm::engine::api::fbresult::RouteT *Asroute() {
    return type == ServiceResponse_route ?
      reinterpret_cast<osrm::engine::api::fbresult::RouteT *>(value) : nullptr;
  }
  const osrm::engine::api::fbresult::RouteT *Asroute() const {
    return type == ServiceResponse_route ?
      reinterpret_cast<const osrm::engine::api::fbresult::RouteT *>(value) : nullptr;
  }
  osrm::engine::api::fbresult::TableT *Astable() {
    return type == ServiceResponse_table ?
      reinterpret_cast<osrm::engine::api::fbresult::TableT *>(value) : nullptr;
  }
  const osrm::engine::api::fbresult::TableT *Astable() const {
    return type == ServiceResponse_table ?
      reinterpret_cast<const osrm::engine::api::fbresult::TableT *>(value) : nullptr;
  }
  osrm::engine::api::fbresult::TripT *Astrip() {
    return type == ServiceResponse_trip ?
      reinterpret_cast<osrm::engine::api::fbresult::TripT *>(value) : nullptr;
  }
  const osrm::engine::api::fbresult::TripT *Astrip() const {
    return type == ServiceResponse_trip ?
      reinterpret_cast<const osrm::engine::api::fbresult::TripT *>(value) : nullptr;
  }
};

bool VerifyServiceResponse(flatbuffers::Verifier &verifier, const void *obj, ServiceResponse type);
bool VerifyServiceResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct PositionT : public flatbuffers::NativeTable {
  typedef Position TableType;
  double longitute;
  double latitude;
  PositionT()
      : longitute(0.0),
        latitude(0.0) {
  }
};

struct Position FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PositionT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUTE = 4,
    VT_LATITUDE = 6
  };
  double longitute() const {
    return GetField<double>(VT_LONGITUTE, 0.0);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUTE) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           verifier.EndTable();
  }
  PositionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PositionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Position> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PositionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longitute(double longitute) {
    fbb_.AddElement<double>(Position::VT_LONGITUTE, longitute, 0.0);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(Position::VT_LATITUDE, latitude, 0.0);
  }
  explicit PositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionBuilder &operator=(const PositionBuilder &);
  flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline flatbuffers::Offset<Position> CreatePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    double longitute = 0.0,
    double latitude = 0.0) {
  PositionBuilder builder_(_fbb);
  builder_.add_latitude(latitude);
  builder_.add_longitute(longitute);
  return builder_.Finish();
}

flatbuffers::Offset<Position> CreatePosition(flatbuffers::FlatBufferBuilder &_fbb, const PositionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WaypointT : public flatbuffers::NativeTable {
  typedef Waypoint TableType;
  double longitute;
  double latitude;
  std::string name;
  std::unique_ptr<osrm::engine::api::fbresult::PositionT> location;
  std::vector<double> nodes;
  uint32_t matchings_index;
  uint32_t waypoint_index;
  uint32_t alternatives_count;
  uint32_t trips_index;
  WaypointT()
      : longitute(0.0),
        latitude(0.0),
        matchings_index(0),
        waypoint_index(0),
        alternatives_count(0),
        trips_index(0) {
  }
};

struct Waypoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WaypointT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUTE = 4,
    VT_LATITUDE = 6,
    VT_NAME = 8,
    VT_LOCATION = 10,
    VT_NODES = 12,
    VT_MATCHINGS_INDEX = 14,
    VT_WAYPOINT_INDEX = 16,
    VT_ALTERNATIVES_COUNT = 18,
    VT_TRIPS_INDEX = 20
  };
  double longitute() const {
    return GetField<double>(VT_LONGITUTE, 0.0);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const osrm::engine::api::fbresult::Position *location() const {
    return GetPointer<const osrm::engine::api::fbresult::Position *>(VT_LOCATION);
  }
  const flatbuffers::Vector<double> *nodes() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_NODES);
  }
  uint32_t matchings_index() const {
    return GetField<uint32_t>(VT_MATCHINGS_INDEX, 0);
  }
  uint32_t waypoint_index() const {
    return GetField<uint32_t>(VT_WAYPOINT_INDEX, 0);
  }
  uint32_t alternatives_count() const {
    return GetField<uint32_t>(VT_ALTERNATIVES_COUNT, 0);
  }
  uint32_t trips_index() const {
    return GetField<uint32_t>(VT_TRIPS_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUTE) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           VerifyField<uint32_t>(verifier, VT_MATCHINGS_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_WAYPOINT_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_ALTERNATIVES_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_TRIPS_INDEX) &&
           verifier.EndTable();
  }
  WaypointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WaypointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Waypoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WaypointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WaypointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longitute(double longitute) {
    fbb_.AddElement<double>(Waypoint::VT_LONGITUTE, longitute, 0.0);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(Waypoint::VT_LATITUDE, latitude, 0.0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Waypoint::VT_NAME, name);
  }
  void add_location(flatbuffers::Offset<osrm::engine::api::fbresult::Position> location) {
    fbb_.AddOffset(Waypoint::VT_LOCATION, location);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<double>> nodes) {
    fbb_.AddOffset(Waypoint::VT_NODES, nodes);
  }
  void add_matchings_index(uint32_t matchings_index) {
    fbb_.AddElement<uint32_t>(Waypoint::VT_MATCHINGS_INDEX, matchings_index, 0);
  }
  void add_waypoint_index(uint32_t waypoint_index) {
    fbb_.AddElement<uint32_t>(Waypoint::VT_WAYPOINT_INDEX, waypoint_index, 0);
  }
  void add_alternatives_count(uint32_t alternatives_count) {
    fbb_.AddElement<uint32_t>(Waypoint::VT_ALTERNATIVES_COUNT, alternatives_count, 0);
  }
  void add_trips_index(uint32_t trips_index) {
    fbb_.AddElement<uint32_t>(Waypoint::VT_TRIPS_INDEX, trips_index, 0);
  }
  explicit WaypointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaypointBuilder &operator=(const WaypointBuilder &);
  flatbuffers::Offset<Waypoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Waypoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Waypoint> CreateWaypoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    double longitute = 0.0,
    double latitude = 0.0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<osrm::engine::api::fbresult::Position> location = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> nodes = 0,
    uint32_t matchings_index = 0,
    uint32_t waypoint_index = 0,
    uint32_t alternatives_count = 0,
    uint32_t trips_index = 0) {
  WaypointBuilder builder_(_fbb);
  builder_.add_latitude(latitude);
  builder_.add_longitute(longitute);
  builder_.add_trips_index(trips_index);
  builder_.add_alternatives_count(alternatives_count);
  builder_.add_waypoint_index(waypoint_index);
  builder_.add_matchings_index(matchings_index);
  builder_.add_nodes(nodes);
  builder_.add_location(location);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Waypoint> CreateWaypointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double longitute = 0.0,
    double latitude = 0.0,
    const char *name = nullptr,
    flatbuffers::Offset<osrm::engine::api::fbresult::Position> location = 0,
    const std::vector<double> *nodes = nullptr,
    uint32_t matchings_index = 0,
    uint32_t waypoint_index = 0,
    uint32_t alternatives_count = 0,
    uint32_t trips_index = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<double>(*nodes) : 0;
  return osrm::engine::api::fbresult::CreateWaypoint(
      _fbb,
      longitute,
      latitude,
      name__,
      location,
      nodes__,
      matchings_index,
      waypoint_index,
      alternatives_count,
      trips_index);
}

flatbuffers::Offset<Waypoint> CreateWaypoint(flatbuffers::FlatBufferBuilder &_fbb, const WaypointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
  typedef Metadata TableType;
  std::vector<std::string> datasource_names;
  MetadataT() {
  }
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATASOURCE_NAMES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *datasource_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATASOURCE_NAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATASOURCE_NAMES) &&
           verifier.VerifyVector(datasource_names()) &&
           verifier.VerifyVectorOfStrings(datasource_names()) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_datasource_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> datasource_names) {
    fbb_.AddOffset(Metadata::VT_DATASOURCE_NAMES, datasource_names);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataBuilder &operator=(const MetadataBuilder &);
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> datasource_names = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_datasource_names(datasource_names);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *datasource_names = nullptr) {
  auto datasource_names__ = datasource_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*datasource_names) : 0;
  return osrm::engine::api::fbresult::CreateMetadata(
      _fbb,
      datasource_names__);
}

flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnnotationT : public flatbuffers::NativeTable {
  typedef Annotation TableType;
  std::vector<uint32_t> distance;
  std::vector<uint32_t> duration;
  std::vector<uint32_t> datasources;
  std::vector<uint32_t> nodes;
  std::vector<uint32_t> weight;
  std::vector<double> speed;
  std::unique_ptr<osrm::engine::api::fbresult::MetadataT> metadata;
  AnnotationT() {
  }
};

struct Annotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnnotationT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_DATASOURCES = 8,
    VT_NODES = 10,
    VT_WEIGHT = 12,
    VT_SPEED = 14,
    VT_METADATA = 16
  };
  const flatbuffers::Vector<uint32_t> *distance() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DISTANCE);
  }
  const flatbuffers::Vector<uint32_t> *duration() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DURATION);
  }
  const flatbuffers::Vector<uint32_t> *datasources() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATASOURCES);
  }
  const flatbuffers::Vector<uint32_t> *nodes() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODES);
  }
  const flatbuffers::Vector<uint32_t> *weight() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<double> *speed() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_SPEED);
  }
  const osrm::engine::api::fbresult::Metadata *metadata() const {
    return GetPointer<const osrm::engine::api::fbresult::Metadata *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISTANCE) &&
           verifier.VerifyVector(distance()) &&
           VerifyOffset(verifier, VT_DURATION) &&
           verifier.VerifyVector(duration()) &&
           VerifyOffset(verifier, VT_DATASOURCES) &&
           verifier.VerifyVector(datasources()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyVector(speed()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
  AnnotationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnnotationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Annotation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnnotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distance(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> distance) {
    fbb_.AddOffset(Annotation::VT_DISTANCE, distance);
  }
  void add_duration(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> duration) {
    fbb_.AddOffset(Annotation::VT_DURATION, duration);
  }
  void add_datasources(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> datasources) {
    fbb_.AddOffset(Annotation::VT_DATASOURCES, datasources);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodes) {
    fbb_.AddOffset(Annotation::VT_NODES, nodes);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> weight) {
    fbb_.AddOffset(Annotation::VT_WEIGHT, weight);
  }
  void add_speed(flatbuffers::Offset<flatbuffers::Vector<double>> speed) {
    fbb_.AddOffset(Annotation::VT_SPEED, speed);
  }
  void add_metadata(flatbuffers::Offset<osrm::engine::api::fbresult::Metadata> metadata) {
    fbb_.AddOffset(Annotation::VT_METADATA, metadata);
  }
  explicit AnnotationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnnotationBuilder &operator=(const AnnotationBuilder &);
  flatbuffers::Offset<Annotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Annotation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Annotation> CreateAnnotation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> distance = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> duration = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> datasources = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> speed = 0,
    flatbuffers::Offset<osrm::engine::api::fbresult::Metadata> metadata = 0) {
  AnnotationBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_speed(speed);
  builder_.add_weight(weight);
  builder_.add_nodes(nodes);
  builder_.add_datasources(datasources);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  return builder_.Finish();
}

inline flatbuffers::Offset<Annotation> CreateAnnotationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *distance = nullptr,
    const std::vector<uint32_t> *duration = nullptr,
    const std::vector<uint32_t> *datasources = nullptr,
    const std::vector<uint32_t> *nodes = nullptr,
    const std::vector<uint32_t> *weight = nullptr,
    const std::vector<double> *speed = nullptr,
    flatbuffers::Offset<osrm::engine::api::fbresult::Metadata> metadata = 0) {
  auto distance__ = distance ? _fbb.CreateVector<uint32_t>(*distance) : 0;
  auto duration__ = duration ? _fbb.CreateVector<uint32_t>(*duration) : 0;
  auto datasources__ = datasources ? _fbb.CreateVector<uint32_t>(*datasources) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<uint32_t>(*nodes) : 0;
  auto weight__ = weight ? _fbb.CreateVector<uint32_t>(*weight) : 0;
  auto speed__ = speed ? _fbb.CreateVector<double>(*speed) : 0;
  return osrm::engine::api::fbresult::CreateAnnotation(
      _fbb,
      distance__,
      duration__,
      datasources__,
      nodes__,
      weight__,
      speed__,
      metadata);
}

flatbuffers::Offset<Annotation> CreateAnnotation(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StepManeuverT : public flatbuffers::NativeTable {
  typedef StepManeuver TableType;
  std::unique_ptr<osrm::engine::api::fbresult::PositionT> location;
  uint16_t bearing_before;
  uint16_t bearing_after;
  osrm::engine::api::fbresult::ManeuverType type;
  osrm::engine::api::fbresult::Turn modifier;
  uint8_t exit;
  StepManeuverT()
      : bearing_before(0),
        bearing_after(0),
        type(osrm::engine::api::fbresult::ManeuverType_Turn),
        modifier(osrm::engine::api::fbresult::Turn_None),
        exit(0) {
  }
};

struct StepManeuver FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StepManeuverT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION = 4,
    VT_BEARING_BEFORE = 6,
    VT_BEARING_AFTER = 8,
    VT_TYPE = 10,
    VT_MODIFIER = 12,
    VT_EXIT = 14
  };
  const osrm::engine::api::fbresult::Position *location() const {
    return GetPointer<const osrm::engine::api::fbresult::Position *>(VT_LOCATION);
  }
  uint16_t bearing_before() const {
    return GetField<uint16_t>(VT_BEARING_BEFORE, 0);
  }
  uint16_t bearing_after() const {
    return GetField<uint16_t>(VT_BEARING_AFTER, 0);
  }
  osrm::engine::api::fbresult::ManeuverType type() const {
    return static_cast<osrm::engine::api::fbresult::ManeuverType>(GetField<int8_t>(VT_TYPE, 0));
  }
  osrm::engine::api::fbresult::Turn modifier() const {
    return static_cast<osrm::engine::api::fbresult::Turn>(GetField<int8_t>(VT_MODIFIER, 0));
  }
  uint8_t exit() const {
    return GetField<uint8_t>(VT_EXIT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyField<uint16_t>(verifier, VT_BEARING_BEFORE) &&
           VerifyField<uint16_t>(verifier, VT_BEARING_AFTER) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_MODIFIER) &&
           VerifyField<uint8_t>(verifier, VT_EXIT) &&
           verifier.EndTable();
  }
  StepManeuverT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StepManeuverT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StepManeuver> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StepManeuverT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StepManeuverBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(flatbuffers::Offset<osrm::engine::api::fbresult::Position> location) {
    fbb_.AddOffset(StepManeuver::VT_LOCATION, location);
  }
  void add_bearing_before(uint16_t bearing_before) {
    fbb_.AddElement<uint16_t>(StepManeuver::VT_BEARING_BEFORE, bearing_before, 0);
  }
  void add_bearing_after(uint16_t bearing_after) {
    fbb_.AddElement<uint16_t>(StepManeuver::VT_BEARING_AFTER, bearing_after, 0);
  }
  void add_type(osrm::engine::api::fbresult::ManeuverType type) {
    fbb_.AddElement<int8_t>(StepManeuver::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_modifier(osrm::engine::api::fbresult::Turn modifier) {
    fbb_.AddElement<int8_t>(StepManeuver::VT_MODIFIER, static_cast<int8_t>(modifier), 0);
  }
  void add_exit(uint8_t exit) {
    fbb_.AddElement<uint8_t>(StepManeuver::VT_EXIT, exit, 0);
  }
  explicit StepManeuverBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StepManeuverBuilder &operator=(const StepManeuverBuilder &);
  flatbuffers::Offset<StepManeuver> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StepManeuver>(end);
    return o;
  }
};

inline flatbuffers::Offset<StepManeuver> CreateStepManeuver(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<osrm::engine::api::fbresult::Position> location = 0,
    uint16_t bearing_before = 0,
    uint16_t bearing_after = 0,
    osrm::engine::api::fbresult::ManeuverType type = osrm::engine::api::fbresult::ManeuverType_Turn,
    osrm::engine::api::fbresult::Turn modifier = osrm::engine::api::fbresult::Turn_None,
    uint8_t exit = 0) {
  StepManeuverBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_bearing_after(bearing_after);
  builder_.add_bearing_before(bearing_before);
  builder_.add_exit(exit);
  builder_.add_modifier(modifier);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<StepManeuver> CreateStepManeuver(flatbuffers::FlatBufferBuilder &_fbb, const StepManeuverT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaneT : public flatbuffers::NativeTable {
  typedef Lane TableType;
  std::vector<osrm::engine::api::fbresult::Turn> indications;
  bool valid;
  LaneT()
      : valid(false) {
  }
};

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaneT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICATIONS = 4,
    VT_VALID = 6
  };
  const flatbuffers::Vector<int8_t> *indications() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_INDICATIONS);
  }
  bool valid() const {
    return GetField<uint8_t>(VT_VALID, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICATIONS) &&
           verifier.VerifyVector(indications()) &&
           VerifyField<uint8_t>(verifier, VT_VALID) &&
           verifier.EndTable();
  }
  LaneT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaneT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lane> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaneT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indications(flatbuffers::Offset<flatbuffers::Vector<int8_t>> indications) {
    fbb_.AddOffset(Lane::VT_INDICATIONS, indications);
  }
  void add_valid(bool valid) {
    fbb_.AddElement<uint8_t>(Lane::VT_VALID, static_cast<uint8_t>(valid), 0);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> indications = 0,
    bool valid = false) {
  LaneBuilder builder_(_fbb);
  builder_.add_indications(indications);
  builder_.add_valid(valid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Lane> CreateLaneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *indications = nullptr,
    bool valid = false) {
  auto indications__ = indications ? _fbb.CreateVector<int8_t>(*indications) : 0;
  return osrm::engine::api::fbresult::CreateLane(
      _fbb,
      indications__,
      valid);
}

flatbuffers::Offset<Lane> CreateLane(flatbuffers::FlatBufferBuilder &_fbb, const LaneT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntersectionT : public flatbuffers::NativeTable {
  typedef Intersection TableType;
  std::unique_ptr<osrm::engine::api::fbresult::PositionT> location;
  std::vector<uint16_t> bearings;
  std::vector<std::string> classes;
  std::vector<bool> entry;
  uint32_t in;
  uint32_t out;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::LaneT>> lanes;
  IntersectionT()
      : in(0),
        out(0) {
  }
};

struct Intersection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntersectionT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION = 4,
    VT_BEARINGS = 6,
    VT_CLASSES = 8,
    VT_ENTRY = 10,
    VT_IN = 12,
    VT_OUT = 14,
    VT_LANES = 16
  };
  const osrm::engine::api::fbresult::Position *location() const {
    return GetPointer<const osrm::engine::api::fbresult::Position *>(VT_LOCATION);
  }
  const flatbuffers::Vector<uint16_t> *bearings() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_BEARINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *classes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CLASSES);
  }
  const flatbuffers::Vector<uint8_t> *entry() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ENTRY);
  }
  uint32_t in() const {
    return GetField<uint32_t>(VT_IN, 0);
  }
  uint32_t out() const {
    return GetField<uint32_t>(VT_OUT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_BEARINGS) &&
           verifier.VerifyVector(bearings()) &&
           VerifyOffset(verifier, VT_CLASSES) &&
           verifier.VerifyVector(classes()) &&
           verifier.VerifyVectorOfStrings(classes()) &&
           VerifyOffset(verifier, VT_ENTRY) &&
           verifier.VerifyVector(entry()) &&
           VerifyField<uint32_t>(verifier, VT_IN) &&
           VerifyField<uint32_t>(verifier, VT_OUT) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
  IntersectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntersectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Intersection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntersectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntersectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location(flatbuffers::Offset<osrm::engine::api::fbresult::Position> location) {
    fbb_.AddOffset(Intersection::VT_LOCATION, location);
  }
  void add_bearings(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> bearings) {
    fbb_.AddOffset(Intersection::VT_BEARINGS, bearings);
  }
  void add_classes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> classes) {
    fbb_.AddOffset(Intersection::VT_CLASSES, classes);
  }
  void add_entry(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entry) {
    fbb_.AddOffset(Intersection::VT_ENTRY, entry);
  }
  void add_in(uint32_t in) {
    fbb_.AddElement<uint32_t>(Intersection::VT_IN, in, 0);
  }
  void add_out(uint32_t out) {
    fbb_.AddElement<uint32_t>(Intersection::VT_OUT, out, 0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>>> lanes) {
    fbb_.AddOffset(Intersection::VT_LANES, lanes);
  }
  explicit IntersectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntersectionBuilder &operator=(const IntersectionBuilder &);
  flatbuffers::Offset<Intersection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Intersection>(end);
    return o;
  }
};

inline flatbuffers::Offset<Intersection> CreateIntersection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<osrm::engine::api::fbresult::Position> location = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> bearings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> classes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entry = 0,
    uint32_t in = 0,
    uint32_t out = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>>> lanes = 0) {
  IntersectionBuilder builder_(_fbb);
  builder_.add_lanes(lanes);
  builder_.add_out(out);
  builder_.add_in(in);
  builder_.add_entry(entry);
  builder_.add_classes(classes);
  builder_.add_bearings(bearings);
  builder_.add_location(location);
  return builder_.Finish();
}

inline flatbuffers::Offset<Intersection> CreateIntersectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<osrm::engine::api::fbresult::Position> location = 0,
    const std::vector<uint16_t> *bearings = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *classes = nullptr,
    const std::vector<uint8_t> *entry = nullptr,
    uint32_t in = 0,
    uint32_t out = 0,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> *lanes = nullptr) {
  auto bearings__ = bearings ? _fbb.CreateVector<uint16_t>(*bearings) : 0;
  auto classes__ = classes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*classes) : 0;
  auto entry__ = entry ? _fbb.CreateVector<uint8_t>(*entry) : 0;
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>>(*lanes) : 0;
  return osrm::engine::api::fbresult::CreateIntersection(
      _fbb,
      location,
      bearings__,
      classes__,
      entry__,
      in,
      out,
      lanes__);
}

flatbuffers::Offset<Intersection> CreateIntersection(flatbuffers::FlatBufferBuilder &_fbb, const IntersectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PolylineT : public flatbuffers::NativeTable {
  typedef Polyline TableType;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::PositionT>> polyline;
  PolylineT() {
  }
};

struct Polyline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolylineT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLYLINE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>> *polyline() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>> *>(VT_POLYLINE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POLYLINE) &&
           verifier.VerifyVector(polyline()) &&
           verifier.VerifyVectorOfTables(polyline()) &&
           verifier.EndTable();
  }
  PolylineT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolylineT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Polyline> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolylineT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PolylineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_polyline(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>>> polyline) {
    fbb_.AddOffset(Polyline::VT_POLYLINE, polyline);
  }
  explicit PolylineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolylineBuilder &operator=(const PolylineBuilder &);
  flatbuffers::Offset<Polyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Polyline>(end);
    return o;
  }
};

inline flatbuffers::Offset<Polyline> CreatePolyline(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>>> polyline = 0) {
  PolylineBuilder builder_(_fbb);
  builder_.add_polyline(polyline);
  return builder_.Finish();
}

inline flatbuffers::Offset<Polyline> CreatePolylineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>> *polyline = nullptr) {
  auto polyline__ = polyline ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>>(*polyline) : 0;
  return osrm::engine::api::fbresult::CreatePolyline(
      _fbb,
      polyline__);
}

flatbuffers::Offset<Polyline> CreatePolyline(flatbuffers::FlatBufferBuilder &_fbb, const PolylineT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StepT : public flatbuffers::NativeTable {
  typedef Step TableType;
  double distance;
  double duration;
  GeometryUnion geometry;
  std::string name;
  uint32_t ref;
  std::string pronunciation;
  std::vector<std::string> destinations;
  std::vector<std::string> exits;
  std::string mode;
  std::unique_ptr<osrm::engine::api::fbresult::StepManeuverT> maneuver;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::IntersectionT>> intersections;
  std::string rotary_name;
  std::string rotary_pronunciation;
  bool driving_side;
  StepT()
      : distance(0.0),
        duration(0.0),
        ref(0),
        driving_side(false) {
  }
};

struct Step FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StepT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_GEOMETRY_TYPE = 8,
    VT_GEOMETRY = 10,
    VT_NAME = 12,
    VT_REF = 14,
    VT_PRONUNCIATION = 16,
    VT_DESTINATIONS = 18,
    VT_EXITS = 20,
    VT_MODE = 22,
    VT_MANEUVER = 24,
    VT_INTERSECTIONS = 26,
    VT_ROTARY_NAME = 28,
    VT_ROTARY_PRONUNCIATION = 30,
    VT_DRIVING_SIDE = 32
  };
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  double duration() const {
    return GetField<double>(VT_DURATION, 0.0);
  }
  osrm::engine::api::fbresult::Geometry geometry_type() const {
    return static_cast<osrm::engine::api::fbresult::Geometry>(GetField<uint8_t>(VT_GEOMETRY_TYPE, 0));
  }
  const void *geometry() const {
    return GetPointer<const void *>(VT_GEOMETRY);
  }
  const flatbuffers::String *geometry_as_polyline() const {
    return geometry_type() == osrm::engine::api::fbresult::Geometry_polyline ? static_cast<const flatbuffers::String *>(geometry()) : nullptr;
  }
  const flatbuffers::String *geometry_as_polyline6() const {
    return geometry_type() == osrm::engine::api::fbresult::Geometry_polyline6 ? static_cast<const flatbuffers::String *>(geometry()) : nullptr;
  }
  const osrm::engine::api::fbresult::Polyline *geometry_as_coordinates() const {
    return geometry_type() == osrm::engine::api::fbresult::Geometry_coordinates ? static_cast<const osrm::engine::api::fbresult::Polyline *>(geometry()) : nullptr;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t ref() const {
    return GetField<uint32_t>(VT_REF, 0);
  }
  const flatbuffers::String *pronunciation() const {
    return GetPointer<const flatbuffers::String *>(VT_PRONUNCIATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *destinations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DESTINATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *exits() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EXITS);
  }
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const osrm::engine::api::fbresult::StepManeuver *maneuver() const {
    return GetPointer<const osrm::engine::api::fbresult::StepManeuver *>(VT_MANEUVER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> *intersections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> *>(VT_INTERSECTIONS);
  }
  const flatbuffers::String *rotary_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ROTARY_NAME);
  }
  const flatbuffers::String *rotary_pronunciation() const {
    return GetPointer<const flatbuffers::String *>(VT_ROTARY_PRONUNCIATION);
  }
  bool driving_side() const {
    return GetField<uint8_t>(VT_DRIVING_SIDE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DISTANCE) &&
           VerifyField<double>(verifier, VT_DURATION) &&
           VerifyField<uint8_t>(verifier, VT_GEOMETRY_TYPE) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           VerifyGeometry(verifier, geometry(), geometry_type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_REF) &&
           VerifyOffset(verifier, VT_PRONUNCIATION) &&
           verifier.VerifyString(pronunciation()) &&
           VerifyOffset(verifier, VT_DESTINATIONS) &&
           verifier.VerifyVector(destinations()) &&
           verifier.VerifyVectorOfStrings(destinations()) &&
           VerifyOffset(verifier, VT_EXITS) &&
           verifier.VerifyVector(exits()) &&
           verifier.VerifyVectorOfStrings(exits()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_MANEUVER) &&
           verifier.VerifyTable(maneuver()) &&
           VerifyOffset(verifier, VT_INTERSECTIONS) &&
           verifier.VerifyVector(intersections()) &&
           verifier.VerifyVectorOfTables(intersections()) &&
           VerifyOffset(verifier, VT_ROTARY_NAME) &&
           verifier.VerifyString(rotary_name()) &&
           VerifyOffset(verifier, VT_ROTARY_PRONUNCIATION) &&
           verifier.VerifyString(rotary_pronunciation()) &&
           VerifyField<uint8_t>(verifier, VT_DRIVING_SIDE) &&
           verifier.EndTable();
  }
  StepT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StepT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Step> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StepT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StepBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distance(double distance) {
    fbb_.AddElement<double>(Step::VT_DISTANCE, distance, 0.0);
  }
  void add_duration(double duration) {
    fbb_.AddElement<double>(Step::VT_DURATION, duration, 0.0);
  }
  void add_geometry_type(osrm::engine::api::fbresult::Geometry geometry_type) {
    fbb_.AddElement<uint8_t>(Step::VT_GEOMETRY_TYPE, static_cast<uint8_t>(geometry_type), 0);
  }
  void add_geometry(flatbuffers::Offset<void> geometry) {
    fbb_.AddOffset(Step::VT_GEOMETRY, geometry);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Step::VT_NAME, name);
  }
  void add_ref(uint32_t ref) {
    fbb_.AddElement<uint32_t>(Step::VT_REF, ref, 0);
  }
  void add_pronunciation(flatbuffers::Offset<flatbuffers::String> pronunciation) {
    fbb_.AddOffset(Step::VT_PRONUNCIATION, pronunciation);
  }
  void add_destinations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> destinations) {
    fbb_.AddOffset(Step::VT_DESTINATIONS, destinations);
  }
  void add_exits(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> exits) {
    fbb_.AddOffset(Step::VT_EXITS, exits);
  }
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Step::VT_MODE, mode);
  }
  void add_maneuver(flatbuffers::Offset<osrm::engine::api::fbresult::StepManeuver> maneuver) {
    fbb_.AddOffset(Step::VT_MANEUVER, maneuver);
  }
  void add_intersections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>>> intersections) {
    fbb_.AddOffset(Step::VT_INTERSECTIONS, intersections);
  }
  void add_rotary_name(flatbuffers::Offset<flatbuffers::String> rotary_name) {
    fbb_.AddOffset(Step::VT_ROTARY_NAME, rotary_name);
  }
  void add_rotary_pronunciation(flatbuffers::Offset<flatbuffers::String> rotary_pronunciation) {
    fbb_.AddOffset(Step::VT_ROTARY_PRONUNCIATION, rotary_pronunciation);
  }
  void add_driving_side(bool driving_side) {
    fbb_.AddElement<uint8_t>(Step::VT_DRIVING_SIDE, static_cast<uint8_t>(driving_side), 0);
  }
  explicit StepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StepBuilder &operator=(const StepBuilder &);
  flatbuffers::Offset<Step> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Step>(end);
    return o;
  }
};

inline flatbuffers::Offset<Step> CreateStep(
    flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    osrm::engine::api::fbresult::Geometry geometry_type = osrm::engine::api::fbresult::Geometry_NONE,
    flatbuffers::Offset<void> geometry = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t ref = 0,
    flatbuffers::Offset<flatbuffers::String> pronunciation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> destinations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> exits = 0,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<osrm::engine::api::fbresult::StepManeuver> maneuver = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>>> intersections = 0,
    flatbuffers::Offset<flatbuffers::String> rotary_name = 0,
    flatbuffers::Offset<flatbuffers::String> rotary_pronunciation = 0,
    bool driving_side = false) {
  StepBuilder builder_(_fbb);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  builder_.add_rotary_pronunciation(rotary_pronunciation);
  builder_.add_rotary_name(rotary_name);
  builder_.add_intersections(intersections);
  builder_.add_maneuver(maneuver);
  builder_.add_mode(mode);
  builder_.add_exits(exits);
  builder_.add_destinations(destinations);
  builder_.add_pronunciation(pronunciation);
  builder_.add_ref(ref);
  builder_.add_name(name);
  builder_.add_geometry(geometry);
  builder_.add_driving_side(driving_side);
  builder_.add_geometry_type(geometry_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Step> CreateStepDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    osrm::engine::api::fbresult::Geometry geometry_type = osrm::engine::api::fbresult::Geometry_NONE,
    flatbuffers::Offset<void> geometry = 0,
    const char *name = nullptr,
    uint32_t ref = 0,
    const char *pronunciation = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *destinations = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *exits = nullptr,
    const char *mode = nullptr,
    flatbuffers::Offset<osrm::engine::api::fbresult::StepManeuver> maneuver = 0,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> *intersections = nullptr,
    const char *rotary_name = nullptr,
    const char *rotary_pronunciation = nullptr,
    bool driving_side = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto pronunciation__ = pronunciation ? _fbb.CreateString(pronunciation) : 0;
  auto destinations__ = destinations ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*destinations) : 0;
  auto exits__ = exits ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*exits) : 0;
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto intersections__ = intersections ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>>(*intersections) : 0;
  auto rotary_name__ = rotary_name ? _fbb.CreateString(rotary_name) : 0;
  auto rotary_pronunciation__ = rotary_pronunciation ? _fbb.CreateString(rotary_pronunciation) : 0;
  return osrm::engine::api::fbresult::CreateStep(
      _fbb,
      distance,
      duration,
      geometry_type,
      geometry,
      name__,
      ref,
      pronunciation__,
      destinations__,
      exits__,
      mode__,
      maneuver,
      intersections__,
      rotary_name__,
      rotary_pronunciation__,
      driving_side);
}

flatbuffers::Offset<Step> CreateStep(flatbuffers::FlatBufferBuilder &_fbb, const StepT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LegT : public flatbuffers::NativeTable {
  typedef Leg TableType;
  double distance;
  double duration;
  double weight;
  std::string summary;
  std::unique_ptr<osrm::engine::api::fbresult::AnnotationT> annotations;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::StepT>> steps;
  LegT()
      : distance(0.0),
        duration(0.0),
        weight(0.0) {
  }
};

struct Leg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LegT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_WEIGHT = 8,
    VT_SUMMARY = 10,
    VT_ANNOTATIONS = 12,
    VT_STEPS = 14
  };
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  double duration() const {
    return GetField<double>(VT_DURATION, 0.0);
  }
  double weight() const {
    return GetField<double>(VT_WEIGHT, 0.0);
  }
  const flatbuffers::String *summary() const {
    return GetPointer<const flatbuffers::String *>(VT_SUMMARY);
  }
  const osrm::engine::api::fbresult::Annotation *annotations() const {
    return GetPointer<const osrm::engine::api::fbresult::Annotation *>(VT_ANNOTATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>> *steps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>> *>(VT_STEPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DISTANCE) &&
           VerifyField<double>(verifier, VT_DURATION) &&
           VerifyField<double>(verifier, VT_WEIGHT) &&
           VerifyOffset(verifier, VT_SUMMARY) &&
           verifier.VerifyString(summary()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           verifier.VerifyVectorOfTables(steps()) &&
           verifier.EndTable();
  }
  LegT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LegT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Leg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LegT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LegBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distance(double distance) {
    fbb_.AddElement<double>(Leg::VT_DISTANCE, distance, 0.0);
  }
  void add_duration(double duration) {
    fbb_.AddElement<double>(Leg::VT_DURATION, duration, 0.0);
  }
  void add_weight(double weight) {
    fbb_.AddElement<double>(Leg::VT_WEIGHT, weight, 0.0);
  }
  void add_summary(flatbuffers::Offset<flatbuffers::String> summary) {
    fbb_.AddOffset(Leg::VT_SUMMARY, summary);
  }
  void add_annotations(flatbuffers::Offset<osrm::engine::api::fbresult::Annotation> annotations) {
    fbb_.AddOffset(Leg::VT_ANNOTATIONS, annotations);
  }
  void add_steps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>>> steps) {
    fbb_.AddOffset(Leg::VT_STEPS, steps);
  }
  explicit LegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LegBuilder &operator=(const LegBuilder &);
  flatbuffers::Offset<Leg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Leg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Leg> CreateLeg(
    flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    double weight = 0.0,
    flatbuffers::Offset<flatbuffers::String> summary = 0,
    flatbuffers::Offset<osrm::engine::api::fbresult::Annotation> annotations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>>> steps = 0) {
  LegBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  builder_.add_steps(steps);
  builder_.add_annotations(annotations);
  builder_.add_summary(summary);
  return builder_.Finish();
}

inline flatbuffers::Offset<Leg> CreateLegDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    double weight = 0.0,
    const char *summary = nullptr,
    flatbuffers::Offset<osrm::engine::api::fbresult::Annotation> annotations = 0,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>> *steps = nullptr) {
  auto summary__ = summary ? _fbb.CreateString(summary) : 0;
  auto steps__ = steps ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>>(*steps) : 0;
  return osrm::engine::api::fbresult::CreateLeg(
      _fbb,
      distance,
      duration,
      weight,
      summary__,
      annotations,
      steps__);
}

flatbuffers::Offset<Leg> CreateLeg(flatbuffers::FlatBufferBuilder &_fbb, const LegT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RouteObjectT : public flatbuffers::NativeTable {
  typedef RouteObject TableType;
  double distance;
  double duration;
  double weight;
  std::string weight_name;
  double confidence;
  GeometryUnion geometry;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::LegT>> legs;
  RouteObjectT()
      : distance(0.0),
        duration(0.0),
        weight(0.0),
        confidence(0.0) {
  }
};

struct RouteObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RouteObjectT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_WEIGHT = 8,
    VT_WEIGHT_NAME = 10,
    VT_CONFIDENCE = 12,
    VT_GEOMETRY_TYPE = 14,
    VT_GEOMETRY = 16,
    VT_LEGS = 18
  };
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  double duration() const {
    return GetField<double>(VT_DURATION, 0.0);
  }
  double weight() const {
    return GetField<double>(VT_WEIGHT, 0.0);
  }
  const flatbuffers::String *weight_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT_NAME);
  }
  double confidence() const {
    return GetField<double>(VT_CONFIDENCE, 0.0);
  }
  osrm::engine::api::fbresult::Geometry geometry_type() const {
    return static_cast<osrm::engine::api::fbresult::Geometry>(GetField<uint8_t>(VT_GEOMETRY_TYPE, 0));
  }
  const void *geometry() const {
    return GetPointer<const void *>(VT_GEOMETRY);
  }
  const flatbuffers::String *geometry_as_polyline() const {
    return geometry_type() == osrm::engine::api::fbresult::Geometry_polyline ? static_cast<const flatbuffers::String *>(geometry()) : nullptr;
  }
  const flatbuffers::String *geometry_as_polyline6() const {
    return geometry_type() == osrm::engine::api::fbresult::Geometry_polyline6 ? static_cast<const flatbuffers::String *>(geometry()) : nullptr;
  }
  const osrm::engine::api::fbresult::Polyline *geometry_as_coordinates() const {
    return geometry_type() == osrm::engine::api::fbresult::Geometry_coordinates ? static_cast<const osrm::engine::api::fbresult::Polyline *>(geometry()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> *legs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> *>(VT_LEGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DISTANCE) &&
           VerifyField<double>(verifier, VT_DURATION) &&
           VerifyField<double>(verifier, VT_WEIGHT) &&
           VerifyOffset(verifier, VT_WEIGHT_NAME) &&
           verifier.VerifyString(weight_name()) &&
           VerifyField<double>(verifier, VT_CONFIDENCE) &&
           VerifyField<uint8_t>(verifier, VT_GEOMETRY_TYPE) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           VerifyGeometry(verifier, geometry(), geometry_type()) &&
           VerifyOffset(verifier, VT_LEGS) &&
           verifier.VerifyVector(legs()) &&
           verifier.VerifyVectorOfTables(legs()) &&
           verifier.EndTable();
  }
  RouteObjectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RouteObjectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RouteObject> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RouteObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RouteObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distance(double distance) {
    fbb_.AddElement<double>(RouteObject::VT_DISTANCE, distance, 0.0);
  }
  void add_duration(double duration) {
    fbb_.AddElement<double>(RouteObject::VT_DURATION, duration, 0.0);
  }
  void add_weight(double weight) {
    fbb_.AddElement<double>(RouteObject::VT_WEIGHT, weight, 0.0);
  }
  void add_weight_name(flatbuffers::Offset<flatbuffers::String> weight_name) {
    fbb_.AddOffset(RouteObject::VT_WEIGHT_NAME, weight_name);
  }
  void add_confidence(double confidence) {
    fbb_.AddElement<double>(RouteObject::VT_CONFIDENCE, confidence, 0.0);
  }
  void add_geometry_type(osrm::engine::api::fbresult::Geometry geometry_type) {
    fbb_.AddElement<uint8_t>(RouteObject::VT_GEOMETRY_TYPE, static_cast<uint8_t>(geometry_type), 0);
  }
  void add_geometry(flatbuffers::Offset<void> geometry) {
    fbb_.AddOffset(RouteObject::VT_GEOMETRY, geometry);
  }
  void add_legs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>>> legs) {
    fbb_.AddOffset(RouteObject::VT_LEGS, legs);
  }
  explicit RouteObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RouteObjectBuilder &operator=(const RouteObjectBuilder &);
  flatbuffers::Offset<RouteObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RouteObject>(end);
    return o;
  }
};

inline flatbuffers::Offset<RouteObject> CreateRouteObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    double weight = 0.0,
    flatbuffers::Offset<flatbuffers::String> weight_name = 0,
    double confidence = 0.0,
    osrm::engine::api::fbresult::Geometry geometry_type = osrm::engine::api::fbresult::Geometry_NONE,
    flatbuffers::Offset<void> geometry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>>> legs = 0) {
  RouteObjectBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_weight(weight);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  builder_.add_legs(legs);
  builder_.add_geometry(geometry);
  builder_.add_weight_name(weight_name);
  builder_.add_geometry_type(geometry_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RouteObject> CreateRouteObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    double weight = 0.0,
    const char *weight_name = nullptr,
    double confidence = 0.0,
    osrm::engine::api::fbresult::Geometry geometry_type = osrm::engine::api::fbresult::Geometry_NONE,
    flatbuffers::Offset<void> geometry = 0,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> *legs = nullptr) {
  auto weight_name__ = weight_name ? _fbb.CreateString(weight_name) : 0;
  auto legs__ = legs ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>>(*legs) : 0;
  return osrm::engine::api::fbresult::CreateRouteObject(
      _fbb,
      distance,
      duration,
      weight,
      weight_name__,
      confidence,
      geometry_type,
      geometry,
      legs__);
}

flatbuffers::Offset<RouteObject> CreateRouteObject(flatbuffers::FlatBufferBuilder &_fbb, const RouteObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RouteT : public flatbuffers::NativeTable {
  typedef Route TableType;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::RouteObjectT>> routes;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> waypoints;
  RouteT() {
  }
};

struct Route FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RouteT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTES = 4,
    VT_WAYPOINTS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>> *routes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>> *>(VT_ROUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_WAYPOINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTES) &&
           verifier.VerifyVector(routes()) &&
           verifier.VerifyVectorOfTables(routes()) &&
           VerifyOffset(verifier, VT_WAYPOINTS) &&
           verifier.VerifyVector(waypoints()) &&
           verifier.VerifyVectorOfTables(waypoints()) &&
           verifier.EndTable();
  }
  RouteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RouteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Route> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RouteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RouteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>>> routes) {
    fbb_.AddOffset(Route::VT_ROUTES, routes);
  }
  void add_waypoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints) {
    fbb_.AddOffset(Route::VT_WAYPOINTS, waypoints);
  }
  explicit RouteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RouteBuilder &operator=(const RouteBuilder &);
  flatbuffers::Offset<Route> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Route>(end);
    return o;
  }
};

inline flatbuffers::Offset<Route> CreateRoute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>>> routes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints = 0) {
  RouteBuilder builder_(_fbb);
  builder_.add_waypoints(waypoints);
  builder_.add_routes(routes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Route> CreateRouteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>> *routes = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints = nullptr) {
  auto routes__ = routes ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>>(*routes) : 0;
  auto waypoints__ = waypoints ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*waypoints) : 0;
  return osrm::engine::api::fbresult::CreateRoute(
      _fbb,
      routes__,
      waypoints__);
}

flatbuffers::Offset<Route> CreateRoute(flatbuffers::FlatBufferBuilder &_fbb, const RouteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatchT : public flatbuffers::NativeTable {
  typedef Match TableType;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> tracepoints;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::RouteT>> matchings;
  MatchT() {
  }
};

struct Match FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatchT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACEPOINTS = 4,
    VT_MATCHINGS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *tracepoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_TRACEPOINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> *matchings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> *>(VT_MATCHINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACEPOINTS) &&
           verifier.VerifyVector(tracepoints()) &&
           verifier.VerifyVectorOfTables(tracepoints()) &&
           VerifyOffset(verifier, VT_MATCHINGS) &&
           verifier.VerifyVector(matchings()) &&
           verifier.VerifyVectorOfTables(matchings()) &&
           verifier.EndTable();
  }
  MatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Match> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracepoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> tracepoints) {
    fbb_.AddOffset(Match::VT_TRACEPOINTS, tracepoints);
  }
  void add_matchings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>>> matchings) {
    fbb_.AddOffset(Match::VT_MATCHINGS, matchings);
  }
  explicit MatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatchBuilder &operator=(const MatchBuilder &);
  flatbuffers::Offset<Match> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Match>(end);
    return o;
  }
};

inline flatbuffers::Offset<Match> CreateMatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> tracepoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>>> matchings = 0) {
  MatchBuilder builder_(_fbb);
  builder_.add_matchings(matchings);
  builder_.add_tracepoints(tracepoints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Match> CreateMatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *tracepoints = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> *matchings = nullptr) {
  auto tracepoints__ = tracepoints ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*tracepoints) : 0;
  auto matchings__ = matchings ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>>(*matchings) : 0;
  return osrm::engine::api::fbresult::CreateMatch(
      _fbb,
      tracepoints__,
      matchings__);
}

flatbuffers::Offset<Match> CreateMatch(flatbuffers::FlatBufferBuilder &_fbb, const MatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NearestT : public flatbuffers::NativeTable {
  typedef Nearest TableType;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> waypoints;
  NearestT() {
  }
};

struct Nearest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NearestT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAYPOINTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_WAYPOINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WAYPOINTS) &&
           verifier.VerifyVector(waypoints()) &&
           verifier.VerifyVectorOfTables(waypoints()) &&
           verifier.EndTable();
  }
  NearestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NearestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Nearest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NearestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NearestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waypoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints) {
    fbb_.AddOffset(Nearest::VT_WAYPOINTS, waypoints);
  }
  explicit NearestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NearestBuilder &operator=(const NearestBuilder &);
  flatbuffers::Offset<Nearest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nearest>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nearest> CreateNearest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints = 0) {
  NearestBuilder builder_(_fbb);
  builder_.add_waypoints(waypoints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Nearest> CreateNearestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints = nullptr) {
  auto waypoints__ = waypoints ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*waypoints) : 0;
  return osrm::engine::api::fbresult::CreateNearest(
      _fbb,
      waypoints__);
}

flatbuffers::Offset<Nearest> CreateNearest(flatbuffers::FlatBufferBuilder &_fbb, const NearestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VectorUintT : public flatbuffers::NativeTable {
  typedef VectorUint TableType;
  std::vector<uint32_t> column;
  VectorUintT() {
  }
};

struct VectorUint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorUintT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN = 4
  };
  const flatbuffers::Vector<uint32_t> *column() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_COLUMN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMN) &&
           verifier.VerifyVector(column()) &&
           verifier.EndTable();
  }
  VectorUintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VectorUintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VectorUint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VectorUintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VectorUintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_column(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> column) {
    fbb_.AddOffset(VectorUint::VT_COLUMN, column);
  }
  explicit VectorUintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorUintBuilder &operator=(const VectorUintBuilder &);
  flatbuffers::Offset<VectorUint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorUint>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorUint> CreateVectorUint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> column = 0) {
  VectorUintBuilder builder_(_fbb);
  builder_.add_column(column);
  return builder_.Finish();
}

inline flatbuffers::Offset<VectorUint> CreateVectorUintDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *column = nullptr) {
  auto column__ = column ? _fbb.CreateVector<uint32_t>(*column) : 0;
  return osrm::engine::api::fbresult::CreateVectorUint(
      _fbb,
      column__);
}

flatbuffers::Offset<VectorUint> CreateVectorUint(flatbuffers::FlatBufferBuilder &_fbb, const VectorUintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TableT : public flatbuffers::NativeTable {
  typedef Table TableType;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> waypoints;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::VectorUintT>> durations;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::VectorUintT>> distances;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> sources;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> destinations;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::VectorUintT>> fallback_speed_cells;
  TableT() {
  }
};

struct Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAYPOINTS = 4,
    VT_DURATIONS = 6,
    VT_DISTANCES = 8,
    VT_SOURCES = 10,
    VT_DESTINATIONS = 12,
    VT_FALLBACK_SPEED_CELLS = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_WAYPOINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *durations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *>(VT_DURATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *distances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *>(VT_DISTANCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *sources() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_SOURCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *destinations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_DESTINATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *fallback_speed_cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *>(VT_FALLBACK_SPEED_CELLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WAYPOINTS) &&
           verifier.VerifyVector(waypoints()) &&
           verifier.VerifyVectorOfTables(waypoints()) &&
           VerifyOffset(verifier, VT_DURATIONS) &&
           verifier.VerifyVector(durations()) &&
           verifier.VerifyVectorOfTables(durations()) &&
           VerifyOffset(verifier, VT_DISTANCES) &&
           verifier.VerifyVector(distances()) &&
           verifier.VerifyVectorOfTables(distances()) &&
           VerifyOffset(verifier, VT_SOURCES) &&
           verifier.VerifyVector(sources()) &&
           verifier.VerifyVectorOfTables(sources()) &&
           VerifyOffset(verifier, VT_DESTINATIONS) &&
           verifier.VerifyVector(destinations()) &&
           verifier.VerifyVectorOfTables(destinations()) &&
           VerifyOffset(verifier, VT_FALLBACK_SPEED_CELLS) &&
           verifier.VerifyVector(fallback_speed_cells()) &&
           verifier.VerifyVectorOfTables(fallback_speed_cells()) &&
           verifier.EndTable();
  }
  TableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waypoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints) {
    fbb_.AddOffset(Table::VT_WAYPOINTS, waypoints);
  }
  void add_durations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>> durations) {
    fbb_.AddOffset(Table::VT_DURATIONS, durations);
  }
  void add_distances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>> distances) {
    fbb_.AddOffset(Table::VT_DISTANCES, distances);
  }
  void add_sources(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> sources) {
    fbb_.AddOffset(Table::VT_SOURCES, sources);
  }
  void add_destinations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> destinations) {
    fbb_.AddOffset(Table::VT_DESTINATIONS, destinations);
  }
  void add_fallback_speed_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>> fallback_speed_cells) {
    fbb_.AddOffset(Table::VT_FALLBACK_SPEED_CELLS, fallback_speed_cells);
  }
  explicit TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableBuilder &operator=(const TableBuilder &);
  flatbuffers::Offset<Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<Table> CreateTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>> durations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>> distances = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> sources = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> destinations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>> fallback_speed_cells = 0) {
  TableBuilder builder_(_fbb);
  builder_.add_fallback_speed_cells(fallback_speed_cells);
  builder_.add_destinations(destinations);
  builder_.add_sources(sources);
  builder_.add_distances(distances);
  builder_.add_durations(durations);
  builder_.add_waypoints(waypoints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Table> CreateTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *durations = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *distances = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *sources = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *destinations = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> *fallback_speed_cells = nullptr) {
  auto waypoints__ = waypoints ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*waypoints) : 0;
  auto durations__ = durations ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>(*durations) : 0;
  auto distances__ = distances ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>(*distances) : 0;
  auto sources__ = sources ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*sources) : 0;
  auto destinations__ = destinations ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*destinations) : 0;
  auto fallback_speed_cells__ = fallback_speed_cells ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>>(*fallback_speed_cells) : 0;
  return osrm::engine::api::fbresult::CreateTable(
      _fbb,
      waypoints__,
      durations__,
      distances__,
      sources__,
      destinations__,
      fallback_speed_cells__);
}

flatbuffers::Offset<Table> CreateTable(flatbuffers::FlatBufferBuilder &_fbb, const TableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TripT : public flatbuffers::NativeTable {
  typedef Trip TableType;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::WaypointT>> waypoints;
  std::vector<std::unique_ptr<osrm::engine::api::fbresult::RouteT>> trips;
  TripT() {
  }
};

struct Trip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TripT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAYPOINTS = 4,
    VT_TRIPS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *>(VT_WAYPOINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> *trips() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> *>(VT_TRIPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WAYPOINTS) &&
           verifier.VerifyVector(waypoints()) &&
           verifier.VerifyVectorOfTables(waypoints()) &&
           VerifyOffset(verifier, VT_TRIPS) &&
           verifier.VerifyVector(trips()) &&
           verifier.VerifyVectorOfTables(trips()) &&
           verifier.EndTable();
  }
  TripT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TripT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Trip> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TripT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TripBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waypoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints) {
    fbb_.AddOffset(Trip::VT_WAYPOINTS, waypoints);
  }
  void add_trips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>>> trips) {
    fbb_.AddOffset(Trip::VT_TRIPS, trips);
  }
  explicit TripBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TripBuilder &operator=(const TripBuilder &);
  flatbuffers::Offset<Trip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Trip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trip> CreateTrip(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>> waypoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>>> trips = 0) {
  TripBuilder builder_(_fbb);
  builder_.add_trips(trips);
  builder_.add_waypoints(waypoints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trip> CreateTripDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> *waypoints = nullptr,
    const std::vector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> *trips = nullptr) {
  auto waypoints__ = waypoints ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>>(*waypoints) : 0;
  auto trips__ = trips ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>>(*trips) : 0;
  return osrm::engine::api::fbresult::CreateTrip(
      _fbb,
      waypoints__,
      trips__);
}

flatbuffers::Offset<Trip> CreateTrip(flatbuffers::FlatBufferBuilder &_fbb, const TripT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FBResultT : public flatbuffers::NativeTable {
  typedef FBResult TableType;
  std::string code;
  std::string message;
  ServiceResponseUnion response;
  FBResultT() {
  }
};

struct FBResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FBResultT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_RESPONSE_TYPE = 8,
    VT_RESPONSE = 10
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  osrm::engine::api::fbresult::ServiceResponse response_type() const {
    return static_cast<osrm::engine::api::fbresult::ServiceResponse>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const osrm::engine::api::fbresult::Match *response_as_match() const {
    return response_type() == osrm::engine::api::fbresult::ServiceResponse_match ? static_cast<const osrm::engine::api::fbresult::Match *>(response()) : nullptr;
  }
  const osrm::engine::api::fbresult::Nearest *response_as_nearest() const {
    return response_type() == osrm::engine::api::fbresult::ServiceResponse_nearest ? static_cast<const osrm::engine::api::fbresult::Nearest *>(response()) : nullptr;
  }
  const osrm::engine::api::fbresult::Route *response_as_route() const {
    return response_type() == osrm::engine::api::fbresult::ServiceResponse_route ? static_cast<const osrm::engine::api::fbresult::Route *>(response()) : nullptr;
  }
  const osrm::engine::api::fbresult::Table *response_as_table() const {
    return response_type() == osrm::engine::api::fbresult::ServiceResponse_table ? static_cast<const osrm::engine::api::fbresult::Table *>(response()) : nullptr;
  }
  const osrm::engine::api::fbresult::Trip *response_as_trip() const {
    return response_type() == osrm::engine::api::fbresult::ServiceResponse_trip ? static_cast<const osrm::engine::api::fbresult::Trip *>(response()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyServiceResponse(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
  FBResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FBResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FBResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FBResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const osrm::engine::api::fbresult::Match *FBResult::response_as<osrm::engine::api::fbresult::Match>() const {
  return response_as_match();
}

template<> inline const osrm::engine::api::fbresult::Nearest *FBResult::response_as<osrm::engine::api::fbresult::Nearest>() const {
  return response_as_nearest();
}

template<> inline const osrm::engine::api::fbresult::Route *FBResult::response_as<osrm::engine::api::fbresult::Route>() const {
  return response_as_route();
}

template<> inline const osrm::engine::api::fbresult::Table *FBResult::response_as<osrm::engine::api::fbresult::Table>() const {
  return response_as_table();
}

template<> inline const osrm::engine::api::fbresult::Trip *FBResult::response_as<osrm::engine::api::fbresult::Trip>() const {
  return response_as_trip();
}

struct FBResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(FBResult::VT_CODE, code);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(FBResult::VT_MESSAGE, message);
  }
  void add_response_type(osrm::engine::api::fbresult::ServiceResponse response_type) {
    fbb_.AddElement<uint8_t>(FBResult::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(flatbuffers::Offset<void> response) {
    fbb_.AddOffset(FBResult::VT_RESPONSE, response);
  }
  explicit FBResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FBResultBuilder &operator=(const FBResultBuilder &);
  flatbuffers::Offset<FBResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBResult> CreateFBResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    osrm::engine::api::fbresult::ServiceResponse response_type = osrm::engine::api::fbresult::ServiceResponse_NONE,
    flatbuffers::Offset<void> response = 0) {
  FBResultBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_message(message);
  builder_.add_code(code);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FBResult> CreateFBResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *message = nullptr,
    osrm::engine::api::fbresult::ServiceResponse response_type = osrm::engine::api::fbresult::ServiceResponse_NONE,
    flatbuffers::Offset<void> response = 0) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return osrm::engine::api::fbresult::CreateFBResult(
      _fbb,
      code__,
      message__,
      response_type,
      response);
}

flatbuffers::Offset<FBResult> CreateFBResult(flatbuffers::FlatBufferBuilder &_fbb, const FBResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PositionT *Position::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PositionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Position::UnPackTo(PositionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = longitute(); _o->longitute = _e; };
  { auto _e = latitude(); _o->latitude = _e; };
}

inline flatbuffers::Offset<Position> Position::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PositionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePosition(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Position> CreatePosition(flatbuffers::FlatBufferBuilder &_fbb, const PositionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PositionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _longitute = _o->longitute;
  auto _latitude = _o->latitude;
  return osrm::engine::api::fbresult::CreatePosition(
      _fbb,
      _longitute,
      _latitude);
}

inline WaypointT *Waypoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WaypointT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Waypoint::UnPackTo(WaypointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = longitute(); _o->longitute = _e; };
  { auto _e = latitude(); _o->latitude = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<osrm::engine::api::fbresult::PositionT>(_e->UnPack(_resolver)); };
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = _e->Get(_i); } } };
  { auto _e = matchings_index(); _o->matchings_index = _e; };
  { auto _e = waypoint_index(); _o->waypoint_index = _e; };
  { auto _e = alternatives_count(); _o->alternatives_count = _e; };
  { auto _e = trips_index(); _o->trips_index = _e; };
}

inline flatbuffers::Offset<Waypoint> Waypoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WaypointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWaypoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Waypoint> CreateWaypoint(flatbuffers::FlatBufferBuilder &_fbb, const WaypointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WaypointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _longitute = _o->longitute;
  auto _latitude = _o->latitude;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _location = _o->location ? CreatePosition(_fbb, _o->location.get(), _rehasher) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector(_o->nodes) : 0;
  auto _matchings_index = _o->matchings_index;
  auto _waypoint_index = _o->waypoint_index;
  auto _alternatives_count = _o->alternatives_count;
  auto _trips_index = _o->trips_index;
  return osrm::engine::api::fbresult::CreateWaypoint(
      _fbb,
      _longitute,
      _latitude,
      _name,
      _location,
      _nodes,
      _matchings_index,
      _waypoint_index,
      _alternatives_count,
      _trips_index);
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MetadataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = datasource_names(); if (_e) { _o->datasource_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->datasource_names[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _datasource_names = _o->datasource_names.size() ? _fbb.CreateVectorOfStrings(_o->datasource_names) : 0;
  return osrm::engine::api::fbresult::CreateMetadata(
      _fbb,
      _datasource_names);
}

inline AnnotationT *Annotation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnnotationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Annotation::UnPackTo(AnnotationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = distance(); if (_e) { _o->distance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->distance[_i] = _e->Get(_i); } } };
  { auto _e = duration(); if (_e) { _o->duration.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->duration[_i] = _e->Get(_i); } } };
  { auto _e = datasources(); if (_e) { _o->datasources.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->datasources[_i] = _e->Get(_i); } } };
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = _e->Get(_i); } } };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = speed(); if (_e) { _o->speed.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->speed[_i] = _e->Get(_i); } } };
  { auto _e = metadata(); if (_e) _o->metadata = std::unique_ptr<osrm::engine::api::fbresult::MetadataT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Annotation> Annotation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnnotation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Annotation> CreateAnnotation(flatbuffers::FlatBufferBuilder &_fbb, const AnnotationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnnotationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _distance = _o->distance.size() ? _fbb.CreateVector(_o->distance) : 0;
  auto _duration = _o->duration.size() ? _fbb.CreateVector(_o->duration) : 0;
  auto _datasources = _o->datasources.size() ? _fbb.CreateVector(_o->datasources) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector(_o->nodes) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _speed = _o->speed.size() ? _fbb.CreateVector(_o->speed) : 0;
  auto _metadata = _o->metadata ? CreateMetadata(_fbb, _o->metadata.get(), _rehasher) : 0;
  return osrm::engine::api::fbresult::CreateAnnotation(
      _fbb,
      _distance,
      _duration,
      _datasources,
      _nodes,
      _weight,
      _speed,
      _metadata);
}

inline StepManeuverT *StepManeuver::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StepManeuverT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StepManeuver::UnPackTo(StepManeuverT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<osrm::engine::api::fbresult::PositionT>(_e->UnPack(_resolver)); };
  { auto _e = bearing_before(); _o->bearing_before = _e; };
  { auto _e = bearing_after(); _o->bearing_after = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = modifier(); _o->modifier = _e; };
  { auto _e = exit(); _o->exit = _e; };
}

inline flatbuffers::Offset<StepManeuver> StepManeuver::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StepManeuverT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStepManeuver(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StepManeuver> CreateStepManeuver(flatbuffers::FlatBufferBuilder &_fbb, const StepManeuverT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StepManeuverT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _location = _o->location ? CreatePosition(_fbb, _o->location.get(), _rehasher) : 0;
  auto _bearing_before = _o->bearing_before;
  auto _bearing_after = _o->bearing_after;
  auto _type = _o->type;
  auto _modifier = _o->modifier;
  auto _exit = _o->exit;
  return osrm::engine::api::fbresult::CreateStepManeuver(
      _fbb,
      _location,
      _bearing_before,
      _bearing_after,
      _type,
      _modifier,
      _exit);
}

inline LaneT *Lane::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LaneT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Lane::UnPackTo(LaneT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indications(); if (_e) { _o->indications.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indications[_i] = static_cast<osrm::engine::api::fbresult::Turn>(_e->Get(_i)); } } };
  { auto _e = valid(); _o->valid = _e; };
}

inline flatbuffers::Offset<Lane> Lane::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaneT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLane(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lane> CreateLane(flatbuffers::FlatBufferBuilder &_fbb, const LaneT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaneT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indications = _o->indications.size() ? _fbb.CreateVectorScalarCast<int8_t>(flatbuffers::data(_o->indications), _o->indications.size()) : 0;
  auto _valid = _o->valid;
  return osrm::engine::api::fbresult::CreateLane(
      _fbb,
      _indications,
      _valid);
}

inline IntersectionT *Intersection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IntersectionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Intersection::UnPackTo(IntersectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<osrm::engine::api::fbresult::PositionT>(_e->UnPack(_resolver)); };
  { auto _e = bearings(); if (_e) { _o->bearings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bearings[_i] = _e->Get(_i); } } };
  { auto _e = classes(); if (_e) { _o->classes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->classes[_i] = _e->Get(_i)->str(); } } };
  { auto _e = entry(); if (_e) { _o->entry.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->entry[_i] = _e->Get(_i) != 0; } } };
  { auto _e = in(); _o->in = _e; };
  { auto _e = out(); _o->out = _e; };
  { auto _e = lanes(); if (_e) { _o->lanes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lanes[_i] = std::unique_ptr<osrm::engine::api::fbresult::LaneT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Intersection> Intersection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntersectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntersection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Intersection> CreateIntersection(flatbuffers::FlatBufferBuilder &_fbb, const IntersectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IntersectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _location = _o->location ? CreatePosition(_fbb, _o->location.get(), _rehasher) : 0;
  auto _bearings = _o->bearings.size() ? _fbb.CreateVector(_o->bearings) : 0;
  auto _classes = _o->classes.size() ? _fbb.CreateVectorOfStrings(_o->classes) : 0;
  auto _entry = _o->entry.size() ? _fbb.CreateVector(_o->entry) : 0;
  auto _in = _o->in;
  auto _out = _o->out;
  auto _lanes = _o->lanes.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> (_o->lanes.size(), [](size_t i, _VectorArgs *__va) { return CreateLane(*__va->__fbb, __va->__o->lanes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateIntersection(
      _fbb,
      _location,
      _bearings,
      _classes,
      _entry,
      _in,
      _out,
      _lanes);
}

inline PolylineT *Polyline::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PolylineT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Polyline::UnPackTo(PolylineT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = polyline(); if (_e) { _o->polyline.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->polyline[_i] = std::unique_ptr<osrm::engine::api::fbresult::PositionT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Polyline> Polyline::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PolylineT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolyline(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Polyline> CreatePolyline(flatbuffers::FlatBufferBuilder &_fbb, const PolylineT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PolylineT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _polyline = _o->polyline.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Position>> (_o->polyline.size(), [](size_t i, _VectorArgs *__va) { return CreatePosition(*__va->__fbb, __va->__o->polyline[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreatePolyline(
      _fbb,
      _polyline);
}

inline StepT *Step::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StepT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Step::UnPackTo(StepT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = distance(); _o->distance = _e; };
  { auto _e = duration(); _o->duration = _e; };
  { auto _e = geometry_type(); _o->geometry.type = _e; };
  { auto _e = geometry(); if (_e) _o->geometry.value = GeometryUnion::UnPack(_e, geometry_type(), _resolver); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = ref(); _o->ref = _e; };
  { auto _e = pronunciation(); if (_e) _o->pronunciation = _e->str(); };
  { auto _e = destinations(); if (_e) { _o->destinations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->destinations[_i] = _e->Get(_i)->str(); } } };
  { auto _e = exits(); if (_e) { _o->exits.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->exits[_i] = _e->Get(_i)->str(); } } };
  { auto _e = mode(); if (_e) _o->mode = _e->str(); };
  { auto _e = maneuver(); if (_e) _o->maneuver = std::unique_ptr<osrm::engine::api::fbresult::StepManeuverT>(_e->UnPack(_resolver)); };
  { auto _e = intersections(); if (_e) { _o->intersections.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intersections[_i] = std::unique_ptr<osrm::engine::api::fbresult::IntersectionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = rotary_name(); if (_e) _o->rotary_name = _e->str(); };
  { auto _e = rotary_pronunciation(); if (_e) _o->rotary_pronunciation = _e->str(); };
  { auto _e = driving_side(); _o->driving_side = _e; };
}

inline flatbuffers::Offset<Step> Step::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StepT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStep(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Step> CreateStep(flatbuffers::FlatBufferBuilder &_fbb, const StepT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StepT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _distance = _o->distance;
  auto _duration = _o->duration;
  auto _geometry_type = _o->geometry.type;
  auto _geometry = _o->geometry.Pack(_fbb);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _ref = _o->ref;
  auto _pronunciation = _o->pronunciation.empty() ? 0 : _fbb.CreateString(_o->pronunciation);
  auto _destinations = _o->destinations.size() ? _fbb.CreateVectorOfStrings(_o->destinations) : 0;
  auto _exits = _o->exits.size() ? _fbb.CreateVectorOfStrings(_o->exits) : 0;
  auto _mode = _o->mode.empty() ? 0 : _fbb.CreateString(_o->mode);
  auto _maneuver = _o->maneuver ? CreateStepManeuver(_fbb, _o->maneuver.get(), _rehasher) : 0;
  auto _intersections = _o->intersections.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> (_o->intersections.size(), [](size_t i, _VectorArgs *__va) { return CreateIntersection(*__va->__fbb, __va->__o->intersections[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rotary_name = _o->rotary_name.empty() ? 0 : _fbb.CreateString(_o->rotary_name);
  auto _rotary_pronunciation = _o->rotary_pronunciation.empty() ? 0 : _fbb.CreateString(_o->rotary_pronunciation);
  auto _driving_side = _o->driving_side;
  return osrm::engine::api::fbresult::CreateStep(
      _fbb,
      _distance,
      _duration,
      _geometry_type,
      _geometry,
      _name,
      _ref,
      _pronunciation,
      _destinations,
      _exits,
      _mode,
      _maneuver,
      _intersections,
      _rotary_name,
      _rotary_pronunciation,
      _driving_side);
}

inline LegT *Leg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LegT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Leg::UnPackTo(LegT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = distance(); _o->distance = _e; };
  { auto _e = duration(); _o->duration = _e; };
  { auto _e = weight(); _o->weight = _e; };
  { auto _e = summary(); if (_e) _o->summary = _e->str(); };
  { auto _e = annotations(); if (_e) _o->annotations = std::unique_ptr<osrm::engine::api::fbresult::AnnotationT>(_e->UnPack(_resolver)); };
  { auto _e = steps(); if (_e) { _o->steps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->steps[_i] = std::unique_ptr<osrm::engine::api::fbresult::StepT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Leg> Leg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LegT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Leg> CreateLeg(flatbuffers::FlatBufferBuilder &_fbb, const LegT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LegT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _distance = _o->distance;
  auto _duration = _o->duration;
  auto _weight = _o->weight;
  auto _summary = _o->summary.empty() ? 0 : _fbb.CreateString(_o->summary);
  auto _annotations = _o->annotations ? CreateAnnotation(_fbb, _o->annotations.get(), _rehasher) : 0;
  auto _steps = _o->steps.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Step>> (_o->steps.size(), [](size_t i, _VectorArgs *__va) { return CreateStep(*__va->__fbb, __va->__o->steps[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateLeg(
      _fbb,
      _distance,
      _duration,
      _weight,
      _summary,
      _annotations,
      _steps);
}

inline RouteObjectT *RouteObject::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RouteObjectT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RouteObject::UnPackTo(RouteObjectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = distance(); _o->distance = _e; };
  { auto _e = duration(); _o->duration = _e; };
  { auto _e = weight(); _o->weight = _e; };
  { auto _e = weight_name(); if (_e) _o->weight_name = _e->str(); };
  { auto _e = confidence(); _o->confidence = _e; };
  { auto _e = geometry_type(); _o->geometry.type = _e; };
  { auto _e = geometry(); if (_e) _o->geometry.value = GeometryUnion::UnPack(_e, geometry_type(), _resolver); };
  { auto _e = legs(); if (_e) { _o->legs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->legs[_i] = std::unique_ptr<osrm::engine::api::fbresult::LegT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<RouteObject> RouteObject::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RouteObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRouteObject(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RouteObject> CreateRouteObject(flatbuffers::FlatBufferBuilder &_fbb, const RouteObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RouteObjectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _distance = _o->distance;
  auto _duration = _o->duration;
  auto _weight = _o->weight;
  auto _weight_name = _o->weight_name.empty() ? 0 : _fbb.CreateString(_o->weight_name);
  auto _confidence = _o->confidence;
  auto _geometry_type = _o->geometry.type;
  auto _geometry = _o->geometry.Pack(_fbb);
  auto _legs = _o->legs.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> (_o->legs.size(), [](size_t i, _VectorArgs *__va) { return CreateLeg(*__va->__fbb, __va->__o->legs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateRouteObject(
      _fbb,
      _distance,
      _duration,
      _weight,
      _weight_name,
      _confidence,
      _geometry_type,
      _geometry,
      _legs);
}

inline RouteT *Route::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RouteT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Route::UnPackTo(RouteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = routes(); if (_e) { _o->routes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routes[_i] = std::unique_ptr<osrm::engine::api::fbresult::RouteObjectT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = waypoints(); if (_e) { _o->waypoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->waypoints[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Route> Route::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RouteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Route> CreateRoute(flatbuffers::FlatBufferBuilder &_fbb, const RouteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RouteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _routes = _o->routes.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::RouteObject>> (_o->routes.size(), [](size_t i, _VectorArgs *__va) { return CreateRouteObject(*__va->__fbb, __va->__o->routes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _waypoints = _o->waypoints.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->waypoints.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->waypoints[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateRoute(
      _fbb,
      _routes,
      _waypoints);
}

inline MatchT *Match::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatchT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Match::UnPackTo(MatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tracepoints(); if (_e) { _o->tracepoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tracepoints[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = matchings(); if (_e) { _o->matchings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->matchings[_i] = std::unique_ptr<osrm::engine::api::fbresult::RouteT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Match> Match::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Match> CreateMatch(flatbuffers::FlatBufferBuilder &_fbb, const MatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tracepoints = _o->tracepoints.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->tracepoints.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->tracepoints[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _matchings = _o->matchings.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> (_o->matchings.size(), [](size_t i, _VectorArgs *__va) { return CreateRoute(*__va->__fbb, __va->__o->matchings[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateMatch(
      _fbb,
      _tracepoints,
      _matchings);
}

inline NearestT *Nearest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NearestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Nearest::UnPackTo(NearestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = waypoints(); if (_e) { _o->waypoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->waypoints[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Nearest> Nearest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NearestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNearest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Nearest> CreateNearest(flatbuffers::FlatBufferBuilder &_fbb, const NearestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NearestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _waypoints = _o->waypoints.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->waypoints.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->waypoints[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateNearest(
      _fbb,
      _waypoints);
}

inline VectorUintT *VectorUint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new VectorUintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void VectorUint::UnPackTo(VectorUintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = column(); if (_e) { _o->column.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->column[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<VectorUint> VectorUint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VectorUintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVectorUint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VectorUint> CreateVectorUint(flatbuffers::FlatBufferBuilder &_fbb, const VectorUintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VectorUintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _column = _o->column.size() ? _fbb.CreateVector(_o->column) : 0;
  return osrm::engine::api::fbresult::CreateVectorUint(
      _fbb,
      _column);
}

inline TableT *Table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Table::UnPackTo(TableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = waypoints(); if (_e) { _o->waypoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->waypoints[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = durations(); if (_e) { _o->durations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->durations[_i] = std::unique_ptr<osrm::engine::api::fbresult::VectorUintT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = distances(); if (_e) { _o->distances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->distances[_i] = std::unique_ptr<osrm::engine::api::fbresult::VectorUintT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = sources(); if (_e) { _o->sources.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sources[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = destinations(); if (_e) { _o->destinations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->destinations[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = fallback_speed_cells(); if (_e) { _o->fallback_speed_cells.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fallback_speed_cells[_i] = std::unique_ptr<osrm::engine::api::fbresult::VectorUintT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Table> Table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Table> CreateTable(flatbuffers::FlatBufferBuilder &_fbb, const TableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _waypoints = _o->waypoints.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->waypoints.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->waypoints[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _durations = _o->durations.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> (_o->durations.size(), [](size_t i, _VectorArgs *__va) { return CreateVectorUint(*__va->__fbb, __va->__o->durations[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _distances = _o->distances.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> (_o->distances.size(), [](size_t i, _VectorArgs *__va) { return CreateVectorUint(*__va->__fbb, __va->__o->distances[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _sources = _o->sources.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->sources.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->sources[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _destinations = _o->destinations.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->destinations.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->destinations[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _fallback_speed_cells = _o->fallback_speed_cells.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::VectorUint>> (_o->fallback_speed_cells.size(), [](size_t i, _VectorArgs *__va) { return CreateVectorUint(*__va->__fbb, __va->__o->fallback_speed_cells[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateTable(
      _fbb,
      _waypoints,
      _durations,
      _distances,
      _sources,
      _destinations,
      _fallback_speed_cells);
}

inline TripT *Trip::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TripT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Trip::UnPackTo(TripT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = waypoints(); if (_e) { _o->waypoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->waypoints[_i] = std::unique_ptr<osrm::engine::api::fbresult::WaypointT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = trips(); if (_e) { _o->trips.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->trips[_i] = std::unique_ptr<osrm::engine::api::fbresult::RouteT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Trip> Trip::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TripT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrip(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Trip> CreateTrip(flatbuffers::FlatBufferBuilder &_fbb, const TripT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TripT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _waypoints = _o->waypoints.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Waypoint>> (_o->waypoints.size(), [](size_t i, _VectorArgs *__va) { return CreateWaypoint(*__va->__fbb, __va->__o->waypoints[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _trips = _o->trips.size() ? _fbb.CreateVector<flatbuffers::Offset<osrm::engine::api::fbresult::Route>> (_o->trips.size(), [](size_t i, _VectorArgs *__va) { return CreateRoute(*__va->__fbb, __va->__o->trips[i].get(), __va->__rehasher); }, &_va ) : 0;
  return osrm::engine::api::fbresult::CreateTrip(
      _fbb,
      _waypoints,
      _trips);
}

inline FBResultT *FBResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FBResultT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FBResult::UnPackTo(FBResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); };
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  { auto _e = response_type(); _o->response.type = _e; };
  { auto _e = response(); if (_e) _o->response.value = ServiceResponseUnion::UnPack(_e, response_type(), _resolver); };
}

inline flatbuffers::Offset<FBResult> FBResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FBResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFBResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FBResult> CreateFBResult(flatbuffers::FlatBufferBuilder &_fbb, const FBResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FBResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  auto _response_type = _o->response.type;
  auto _response = _o->response.Pack(_fbb);
  return osrm::engine::api::fbresult::CreateFBResult(
      _fbb,
      _code,
      _message,
      _response_type,
      _response);
}

inline bool VerifyGeometry(flatbuffers::Verifier &verifier, const void *obj, Geometry type) {
  switch (type) {
    case Geometry_NONE: {
      return true;
    }
    case Geometry_polyline: {
      auto ptr = reinterpret_cast<const flatbuffers::String *>(obj);
      return verifier.VerifyString(ptr);
    }
    case Geometry_polyline6: {
      auto ptr = reinterpret_cast<const flatbuffers::String *>(obj);
      return verifier.VerifyString(ptr);
    }
    case Geometry_coordinates: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Polyline *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyGeometryVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeometry(
        verifier,  values->Get(i), types->GetEnum<Geometry>(i))) {
      return false;
    }
  }
  return true;
}

inline void *GeometryUnion::UnPack(const void *obj, Geometry type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Geometry_polyline: {
      auto ptr = reinterpret_cast<const flatbuffers::String *>(obj);
      return new std::string(ptr->c_str(), ptr->size());
    }
    case Geometry_polyline6: {
      auto ptr = reinterpret_cast<const flatbuffers::String *>(obj);
      return new std::string(ptr->c_str(), ptr->size());
    }
    case Geometry_coordinates: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Polyline *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> GeometryUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Geometry_polyline: {
      auto ptr = reinterpret_cast<const std::string *>(value);
      return _fbb.CreateString(*ptr).Union();
    }
    case Geometry_polyline6: {
      auto ptr = reinterpret_cast<const std::string *>(value);
      return _fbb.CreateString(*ptr).Union();
    }
    case Geometry_coordinates: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::PolylineT *>(value);
      return CreatePolyline(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline GeometryUnion::GeometryUnion(const GeometryUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Geometry_polyline: {
      value = new std::string(*reinterpret_cast<std::string *>(u.value));
      break;
    }
    case Geometry_polyline6: {
      value = new std::string(*reinterpret_cast<std::string *>(u.value));
      break;
    }
    case Geometry_coordinates: {
      FLATBUFFERS_ASSERT(false);  // osrm::engine::api::fbresult::PolylineT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void GeometryUnion::Reset() {
  switch (type) {
    case Geometry_polyline: {
      auto ptr = reinterpret_cast<std::string *>(value);
      delete ptr;
      break;
    }
    case Geometry_polyline6: {
      auto ptr = reinterpret_cast<std::string *>(value);
      delete ptr;
      break;
    }
    case Geometry_coordinates: {
      auto ptr = reinterpret_cast<osrm::engine::api::fbresult::PolylineT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Geometry_NONE;
}

inline bool VerifyServiceResponse(flatbuffers::Verifier &verifier, const void *obj, ServiceResponse type) {
  switch (type) {
    case ServiceResponse_NONE: {
      return true;
    }
    case ServiceResponse_match: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Match *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServiceResponse_nearest: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Nearest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServiceResponse_route: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Route *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServiceResponse_table: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Table *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServiceResponse_trip: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Trip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyServiceResponseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServiceResponse(
        verifier,  values->Get(i), types->GetEnum<ServiceResponse>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ServiceResponseUnion::UnPack(const void *obj, ServiceResponse type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ServiceResponse_match: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Match *>(obj);
      return ptr->UnPack(resolver);
    }
    case ServiceResponse_nearest: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Nearest *>(obj);
      return ptr->UnPack(resolver);
    }
    case ServiceResponse_route: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Route *>(obj);
      return ptr->UnPack(resolver);
    }
    case ServiceResponse_table: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Table *>(obj);
      return ptr->UnPack(resolver);
    }
    case ServiceResponse_trip: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::Trip *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ServiceResponseUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ServiceResponse_match: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::MatchT *>(value);
      return CreateMatch(_fbb, ptr, _rehasher).Union();
    }
    case ServiceResponse_nearest: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::NearestT *>(value);
      return CreateNearest(_fbb, ptr, _rehasher).Union();
    }
    case ServiceResponse_route: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::RouteT *>(value);
      return CreateRoute(_fbb, ptr, _rehasher).Union();
    }
    case ServiceResponse_table: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::TableT *>(value);
      return CreateTable(_fbb, ptr, _rehasher).Union();
    }
    case ServiceResponse_trip: {
      auto ptr = reinterpret_cast<const osrm::engine::api::fbresult::TripT *>(value);
      return CreateTrip(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ServiceResponseUnion::ServiceResponseUnion(const ServiceResponseUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ServiceResponse_match: {
      FLATBUFFERS_ASSERT(false);  // osrm::engine::api::fbresult::MatchT not copyable.
      break;
    }
    case ServiceResponse_nearest: {
      FLATBUFFERS_ASSERT(false);  // osrm::engine::api::fbresult::NearestT not copyable.
      break;
    }
    case ServiceResponse_route: {
      FLATBUFFERS_ASSERT(false);  // osrm::engine::api::fbresult::RouteT not copyable.
      break;
    }
    case ServiceResponse_table: {
      FLATBUFFERS_ASSERT(false);  // osrm::engine::api::fbresult::TableT not copyable.
      break;
    }
    case ServiceResponse_trip: {
      FLATBUFFERS_ASSERT(false);  // osrm::engine::api::fbresult::TripT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void ServiceResponseUnion::Reset() {
  switch (type) {
    case ServiceResponse_match: {
      auto ptr = reinterpret_cast<osrm::engine::api::fbresult::MatchT *>(value);
      delete ptr;
      break;
    }
    case ServiceResponse_nearest: {
      auto ptr = reinterpret_cast<osrm::engine::api::fbresult::NearestT *>(value);
      delete ptr;
      break;
    }
    case ServiceResponse_route: {
      auto ptr = reinterpret_cast<osrm::engine::api::fbresult::RouteT *>(value);
      delete ptr;
      break;
    }
    case ServiceResponse_table: {
      auto ptr = reinterpret_cast<osrm::engine::api::fbresult::TableT *>(value);
      delete ptr;
      break;
    }
    case ServiceResponse_trip: {
      auto ptr = reinterpret_cast<osrm::engine::api::fbresult::TripT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ServiceResponse_NONE;
}

}  // namespace fbresult
}  // namespace api
}  // namespace engine
}  // namespace osrm

#endif  // FLATBUFFERS_GENERATED_FBRESULT_OSRM_ENGINE_API_FBRESULT_H_
